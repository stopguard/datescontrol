Stage1

index.html
items.html
departaments.html
item_types.html

зайти в папку в которой будет лежать папка вирт окружения.
python3.9 -m venv env
source env/bin/activate
pip install pillow
pip install django==3.2

создаём репо на гитхабе
копируем в папку для проекта файл гитигнор
git init
echo "initial commit" > README.md
git add *
git add .gitignore
git commit -am "initial commit"
git remote add origin git@github.com:stopguard/datescontrol.git
git push --set-upstream origin master
git branch br1
git checkout br1

в пайчарм
New project в прошке выбрать django. 
выставить корневую папку для проекта
выбрать созданное ранее вирт окружение

для старта dev-сервера
python manage.py runserver

для создания приложения в вирт-окружении
django-admin startapp app_name

git add *
git commit -am "mainapp started"
git push --set-upstream origin br1

в settings.py
добавить в INSTALLED_APPS новое приложение

во views.py приложения 
добавить вьюхи - в FBV принимают аргументов request и возвращают его же + обработанный шаблон

в urls.py
добавить импорт вьюх приложений
добавить в urlpatterns ссылки на вьюхи

в settings.py
переменную STATICFILES_DIRS с кортежем содержащим список путей к папкам со статикой

в файлах шаблонов
исправить пути к шаблонам и статике на абсолютные



Stage2

/base.html
/main/index.html
/main/items.html
/main/departaments.html
/main/item_types.html


в корневой в templates
создал base.html


в base.html
оставил только общий для всех страниц контент
добавил шблонный тэг
      {% block content %}
      {% endblock %}
всё что возможно будет нуждаться в переопределении так же заключаем в блоки
для сохранения переопределяемого содержимого используем в блоке
      {{ block.super }}
и добавляем то что хотим добавить.


в остальных html
удалить всё что есть в base.html
заключить оставшееся в блок с названием в который мы хотим добавить данные оставшегося блока
в начале файла указать откуда наследуемся
      {% extends 'base.html' %}


в base.html
заменяем заголовок на плейсхолдер с переменной контекста и шаблонным фильтром capfirst
      {{ page_title|capfirst }}


в views.py приложений
добавляем переменную-словарь context с ключом page_title и значением заголовка страницы.
переменную context передаём в render третьим аргументом


в случае если есть элемент который много где встречается
в папке templates 
создаём папку includes

в папке includes 
создаём нужную папку пространства имён и создаём файл с подходящим именем например inc.html

в файле inc.html
перетаскиваем сюда повторяющийся фрагмент кода

в файлах html содержащих код из inc.html
заменяем повторяющийся фрагмент кода на 
      {% include 'includes/.../inc.html' %}


во всех файлах html со статикой
добавить после extends
      {% load static %}
заменить пути к статическим файлам с
      "/static/css/all.css"
на
      "{% static 'css/all.css' %}"
для упрощения поддержки изменения путей к статике


в urls.py
добавляем третьим аргументом path имя адреса
      path('', mainapp.index, name='index')

во всех html
в ссылках заменяем адреса ссылок на
      {% url 'index' %}


во views.py
в контроллерах страниц со списками передаём в контекст данные для вывода на страницу

в html файлах где подтягиваются эти списки данных
используем тэг
      {% for el in items %}
      {% endfor %}
для вывода повторяющегося содержимого

тэг условный оператор
      {% if test1 %}
      {% elif test2 %}
      {% endif %}

сделал форматирование по временной схеме

передал в котекст данные в items.html и departaments.html
передал в котекст данные в items_types.html



Stage3

модели и бд

создать модель для приложения
в файле app_name/models.py
создаём класс новой модели
class CityModel(models.Model):
    name = models.CharField('Филиал', max_length=256)
    description = models.TextField('Примечание', blank=True)
    photo = models.ImageField(upload_to='city_images', blank=True)
    is_active = models.BooleanField('Активен', default=True)

для текстовых полей если они необязательные должно быть свойство blank=True
для числовых используем default=0
для чарфилда обязательно параметр max_length
для внешних ключей используется тип поля ForeignKey в аргументах указывается модель из которой берётся первичный ключ 
    и аргумент on_delete указывающий действие для записей этой модели при удалении связанной записи внешнего ключа.


для изображений upload_to
    так же для изображений требуется прописать переменные:

    в project_name/settings.py
    добавляем переменные 
    для веб адреса откуда запрашиваются изображения
    MEDIA_URL = '/media_filder_path/'
    для папки в проекте где они будут лежать
    MEDIA_ROOT = BASE_DIR / 'media_filder_path'

    в project_name/urls.py
    импортируем
    from django.conf import settings
    from django.conf.urls.static import static
    добавляем условие для дев-сервера
    if settings.DEBUG:
        urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


после создания моделей создаём и накатываем миграции
python manage.py makemigrations
python manage.py migrate

для добавления моделей во встроенную админку требуется зарегистрировать их
в файле app_name/admin.py
импортируем модели
from app_name.models import ModelName1, ModelName2...

регистрируем модели
admin.site.register(ModelName1)
admin.site.register(ModelName2)

добавил тестовые данные в бд

добавил логику в модель предметов
доработал контекст и шаблон в модели предметов

доработал модель предметов
добавил в модель работника определение статуса работника и определение статуса бригадира

добавил модели в контекст

распилил mainapp на приложения mainapp, itemtypesapp, workersapp



Stage4

добавил диспетчеры адресов
в datescontrol/urls.py
импортируем из django.urls функцию include
для каждого приложения создаём паттерн с неймспейсом:
path('<approotpath>/', include('<appname>.urls', namespace='<spacename>'))

в каждой папке приложения создаём файл urls.py
в нём 
импортируем path из gjango.urls
импортируем вьюхи приложения (import <appname>.views as <appname>)
объявляем имя приложения (app_name = '<appname>')
создаём переменную urlpatterns со списком паттернов:
path('<viewrootpath>/', <appname|appname.views>.<viewname>, name='<alias>')

ПЕРЕД ТЕМ КАК СОЗДАВАТЬ СВОЮ МОДЕЛЬ ПОЛЬЗОВАТЕЛЯ НУЖНО СОЗДАТЬ ФИКСТУРЫ ДАННЫХ ПО ПРИЛОЖЕНИЯМ
python manage.py dumpdata <appname> > <appname>.json

добавил в модель поля для фото, полного имени, телеграм-айди, списка телефонов

python manage.py startapp "appname"
для переопределения модели пользователя требуется унаследоваться от абстрактного пользователя джанго.
в authapp/models.py
импортируем AbstractUser из django.contrib.auth.models
и создаём свою модель пользователя:
class <UserModelName>(AbstractUser):
    additional fields

далее удаляем файл с БД, создаём и накатываем миграции.
Создаём суперюзера
python manage.py createsuperuser
Восстанавливаем данные в бд
python manage.py loaddata <dumpfilename>.json

для форм в приложении где они требуются создаётся скрипт forms.py
в файле authapp/forms.py
импортируем AuthenticationForm из django.contrib.auth.forms
создаём форму:
class <FormName>(AuthenticationForm):
    def __init__(self, *args, **kwargs):    # переопределяем конструктор формы
        super().__init__(*args, **kwargs)   # пробрасываем приходящие данные дальше в родителя
        for field_name, field in self.fields.items():  # забираем из словаря полей ключи-значения полей
            field.widget.attrs['class'] = f'newclasses'  # добавляем новые классы в поля для стилизации

так же можно более подробно расписать поля:
    from django.contrib.auth import get_user_model
    from django.contrib.auth.forms import UserChangeForm
    from django.forms import forms
    from django import forms as forms_lib

    class ShopUserProfileForm(UserChangeForm):
        first_name = forms_lib.CharField(widget=forms_lib.TextInput(attrs={'class': 'form-control py-4',
                                                                           'placeholder': 'Введите имя'}), required=False)
        last_name = forms_lib.CharField(widget=forms_lib.TextInput(attrs={'class': 'form-control py-4',
                                                                          'placeholder': 'Введите фамилию'}),
                                        required=False)
        email = forms_lib.EmailField(widget=forms_lib.EmailInput(attrs={'class': 'form-control py-4',
                                                                        'readonly': True}))
        username = forms_lib.CharField(widget=forms_lib.TextInput(attrs={'class': 'form-control py-4',
                                                                         'readonly': True}))
        avatar = forms_lib.ImageField(widget=forms_lib.FileInput(attrs={'class': 'custom-file-input'}), required=False)

        class Meta:
            model = get_user_model()
            fields = ('username', 'first_name', 'last_name', 'email', 'avatar', 'password')

        # кастомный валидатор формы
        def clean_username(self):
            u_name = self.cleaned_data['username']
            if len(u_name) < 6:
                raise forms.ValidationError('Длина имени пользователя должна быть не меньше 6 символов')
            return u_name

для авторизации требуется использовать метод POST для безопасности
в файле authapp/views.py:
для входа:
def login(request):
    if request.method == 'POST':                                # если метод POST
        form = UserLoginForm(data=request.POST)                     # обогащаем форму данными
        if form.is_valid():                                         # если форма валидная (если нет отсылаем форму обратно)
            username = request.POST.get('username')                     # забираем из неё пользователя
            password = request.POST.get('password')
            user = auth.authenticate(username=username, password=password)
            if user and user.is_active:                                 # проверяем наличие активного юзера с такими данными
                auth.login(request, user)                                   # генерим печеньку если он есть
                return HttpResponseRedirect(reverse('main:index'))          # отсылаем на мэйн-индекс
    else:
        form = UserLoginForm()                                      # если метод не POST создаём форму и шлём юзеру

    context = {'page_title': 'авторизация',
               'form': form,
               'today': today,
               }
    return render(request, 'authapp/login.html', context)

для выхода:
def logout(request):
    auth.logout(request)        # удаляем печеньку sessionid
    return HttpResponseRedirect(reverse('main:index'))


создал страницу авторизации authapp/templates/authapp/login.html
не забывать создавать csrf_token
использовал автоматически сгенерированную джанго форму "form.as_p"
            <form class="form" method="post">
                {% csrf_token %}
                {{ form.as_p }}
                <br>
                <input class="form-control" type="submit" value="Войти">
            </form>

в templates/base.html
добавил проверку на авторизацию и права суперпользователя:
            {% if user.is_authenticated %}
            {% if user.is_superuser %}


Stage 5

добавил регистрацию


...
СБРОСИТЬ В ПРОЕКТ ВСЕ СТРАНИЦЫ И ОТРЕДАКТИРОВАТЬ ИХ ТОЖЕ после начала работы с формами

после добавления бд и подходом к ajax
РЕШИТЬ ВОПРОС С ПЕРЕДАЧЕЙ НА ФРОНТ ГОРОДОВ С ПРИВЯЗААННЫМИ К НИМ ОРГАНИЗАЦИЯМИ ПОДРАЗДЕЛЕНИЯМИ И БРИГАДИРАМИ
РЕШИТЬ ВОПРОС С ПЕРЕДАЧЕЙ НА ФРОНТ ТИПОВ ПРЕДМЕТОВ С ИХ ПРИВЯЗКОЙ К КЛАССАМ