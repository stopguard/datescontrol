Stage1

index.html
items.html
departaments.html
item_types.html

зайти в папку в которой будет лежать папка вирт окружения.
python3.9 -m venv env
source env/bin/activate
pip install pillow
pip install django==3.2

создаём репо на гитхабе
копируем в папку для проекта файл гитигнор
git init
echo "initial commit" > README.md
git add *
git add .gitignore
git commit -am "initial commit"
git remote add origin git@github.com:stopguard/datescontrol.git
git push --set-upstream origin master
git branch br1
git checkout br1

в пайчарм
New project в прошке выбрать django. 
выставить корневую папку для проекта
выбрать созданное ранее вирт окружение

для старта dev-сервера
python manage.py runserver

для создания приложения в вирт-окружении
django-admin startapp app_name

git add *
git commit -am "mainapp started"
git push --set-upstream origin br1

в settings.py
добавить в INSTALLED_APPS новое приложение

во views.py приложения 
добавить вьюхи - в FBV принимают аргументов request и возвращают его же + обработанный шаблон

в urls.py
добавить импорт вьюх приложений
добавить в urlpatterns ссылки на вьюхи

в settings.py
переменную STATICFILES_DIRS с кортежем содержащим список путей к папкам со статикой

в файлах шаблонов
исправить пути к шаблонам и статике на абсолютные



Stage2

/base.html
/main/index.html
/main/items.html
/main/departaments.html
/main/item_types.html


в корневой в templates
создал base.html


в base.html
оставил только общий для всех страниц контент
добавил шблонный тэг
      {% block content %}
      {% endblock %}
всё что возможно будет нуждаться в переопределении так же заключаем в блоки
для сохранения переопределяемого содержимого используем в блоке
      {{ block.super }}
и добавляем то что хотим добавить.


в остальных html
удалить всё что есть в base.html
заключить оставшееся в блок с названием в который мы хотим добавить данные оставшегося блока
в начале файла указать откуда наследуемся
      {% extends 'base.html' %}


в base.html
заменяем заголовок на плейсхолдер с переменной контекста и шаблонным фильтром capfirst
      {{ page_title|capfirst }}


в views.py приложений
добавляем переменную-словарь context с ключом page_title и значением заголовка страницы.
переменную context передаём в render третьим аргументом


в случае если есть элемент который много где встречается
в папке templates 
создаём папку includes

в папке includes 
создаём нужную папку пространства имён и создаём файл с подходящим именем например inc.html

в файле inc.html
перетаскиваем сюда повторяющийся фрагмент кода

в файлах html содержащих код из inc.html
заменяем повторяющийся фрагмент кода на 
      {% include 'includes/.../inc.html' %}


во всех файлах html со статикой
добавить после extends
      {% load static %}
заменить пути к статическим файлам с
      "/static/css/all.css"
на
      "{% static 'css/all.css' %}"
для упрощения поддержки изменения путей к статике


в urls.py
добавляем третьим аргументом path имя адреса
      path('', mainapp.index, name='index')

во всех html
в ссылках заменяем адреса ссылок на
      {% url 'index' %}


во views.py
в контроллерах страниц со списками передаём в контекст данные для вывода на страницу

в html файлах где подтягиваются эти списки данных
используем тэг
      {% for el in items %}
      {% endfor %}
для вывода повторяющегося содержимого

тэг условный оператор
      {% if test1 %}
      {% elif test2 %}
      {% endif %}

сделал форматирование по временной схеме

передал в котекст данные в items.html и departaments.html
передал в котекст данные в items_types.html



Stage3

модели и бд

создать модель для приложения
в файле app_name/models.py
создаём класс новой модели
class CityModel(models.Model):
    name = models.CharField('Филиал', max_length=256)
    description = models.TextField('Примечание', blank=True)
    photo = models.ImageField(upload_to='city_images', blank=True)
    is_active = models.BooleanField('Активен', default=True)

для текстовых полей если они необязательные должно быть свойство blank=True
для числовых используем default=0
для чарфилда обязательно параметр max_length
для внешних ключей используется тип поля ForeignKey в аргументах указывается модель из которой берётся первичный ключ 
    и аргумент on_delete указывающий действие для записей этой модели при удалении связанной записи внешнего ключа.


для изображений upload_to
    так же для изображений требуется прописать переменные:

    в project_name/settings.py
    добавляем переменные 
    для веб адреса откуда запрашиваются изображения
    MEDIA_URL = '/media_filder_path/'
    для папки в проекте где они будут лежать
    MEDIA_ROOT = BASE_DIR / 'media_filder_path'

    в project_name/urls.py
    импортируем
    from django.conf import settings
    from django.conf.urls.static import static
    добавляем условие для дев-сервера
    if settings.DEBUG:
        urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)


после создания моделей создаём и накатываем миграции
python manage.py makemigrations
python manage.py migrate

для добавления моделей во встроенную админку требуется зарегистрировать их
в файле app_name/admin.py
импортируем модели
from app_name.models import ModelName1, ModelName2...

регистрируем модели
admin.site.register(ModelName1)
admin.site.register(ModelName2)

добавил тестовые данные в бд

добавил логику в модель предметов
доработал контекст и шаблон в модели пользователя

...
СБРОСИТЬ В ПРОЕКТ ВСЕ СТРАНИЦЫ И ОТРЕДАКТИРОВАТЬ ИХ ТОЖЕ

после добавления бд
РЕШИТЬ ВОПРОС С ПЕРЕДАЧЕЙ НА ФРОНТ ГОРОДОВ С ПРИВЯЗААННЫМИ К НИМ ОРГАНИЗАЦИЯМИ ПОДРАЗДЕЛЕНИЯМИ И БРИГАДИРАМИ
РЕШИТЬ ВОПРОС С ПЕРЕДАЧЕЙ НА ФРОНТ ТИПОВ ПРЕДМЕТОВ С ИХ ПРИВЯЗКОЙ К КЛАССАМ